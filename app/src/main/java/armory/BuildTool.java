/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package armory;

import armory.types.*;

import java.io.File;
import java.util.Deque;

/**
 * A tool for building suits of armor
 */
public class BuildTool implements Tool {
    //-------------------------------------------------------------------------
    // Constructor

    public BuildTool() {
        // nothing to do
    }

    //-------------------------------------------------------------------------
    // The App

    @Override public String usage() {
        return "armory build <armory.dat> [options...]";
    }

    @Override public String oneLiner() {
        return "Builds suits of armor from the available pieces.";
    }

    @Override public String help() {
        return """
This tool builds possible suits of armor from the available pieces,
and ranks them according to the user's criteria.  All suits must
meet the user's desired minimum stats.

    -limit num     -- Maximum number of results to display, default is 5
    -mob weight    -- default is 1.0 for each
    -res weight
    -rec weight
    -dis weight
    -int weight
    -str weight
    -minmob value  -- Minimum stat, default is 0
    -minres value  -- Minimum stat, default is 0
    -minrec value  -- Minimum stat, default is 0
    -mindis value  -- Minimum stat, default is 0
    -minint value  -- Minimum stat, default is 0
    -minstr value  -- Minimum stat, default is 0
""";
    }

    @Override
    public void start(Deque<String> args) throws AppError {
        if (args.size() < 1) {
            println("Usage: " + usage());
            System.exit(1);
        }

        // NEXT, parse the command line
        var fileName = args.poll();
        var options = new Options(args);

        // FIRST, load the armor from the file.
        var db = new Armory(new File(fileName));

        println("\nSuits from " + fileName + ":\n");
        db.getSuits().forEach(s -> {
            s.dump();
            println("");
        });

        // NEXT, get the suit to compare with.
        Suit current;

        if (options.getCompareWith() != null) {
            current = db.getSuits().stream()
                .filter(suit -> suit.getName().equals(options.getCompareWith()))
                .findFirst()
                .orElseThrow(() ->
                    new AppError("Unknown suit: " + options.getCompareWith()));
        } else {
            current = (!db.getSuits().isEmpty()) ? db.getSuits().get(0) : null;
        }

        // NEXT, generate the possible choices
        var suits = db.allSuits();

        var comparator = new SuitComparator(options.getWeights());
        var mins = options.getMins();

        suits.sort(comparator.reversed());

        println("Number of possible suits:  " + suits.size());
        println("Possible suits ordered by: " + comparator);
        println("Minimum acceptable stats: " + mins.numbers());
        println("Comparing against suit:    " +
            (current != null ? current.getName() : "n/a"));
        println("");

        var results = suits.stream()
            .filter(set -> set.dominates(mins))
            .limit(options.getLimit())
            .toList();

        for (int i = 0; i < results.size(); i++) {
            results.get(i).setName("Choice #" + (i + 1));
        }

        results.forEach(set -> {
            if (current !=  null) {
                set.dumpComparison(current);
            } else {
                set.dump();
            }
            println("");
        });
    }

    /**
     * The user's input options.
     */
    public class Options {
        private String compareWith = null;
        private int limit = 5;
        private final StatMap mins = new StatMap();
        private final StatWeights weights = new StatWeights();

        /**
         * Parses the options and makes them available to the application.
         * @param opts The command line options
         * @throws AppError On input error
         */
        public Options(Deque<String> opts) throws AppError {
            while (!opts.isEmpty()) {
                var opt = opts.poll();

                if (!opt.startsWith("-")) {
                    throw new AppError("Expected an option: " + opt);
                }

                switch (opt) {
                    case "-limit" ->
                        limit = requirePositiveInteger(opt, opts);
                    case "-compare" ->
                        compareWith = requireString(opt, opts);
                    case "-mob" ->
                        weights.put(Stat.MOB, requireWeight(opt, opts));
                    case "-res" ->
                        weights.put(Stat.RES, requireWeight(opt, opts));
                    case "-rec" ->
                        weights.put(Stat.REC, requireWeight(opt, opts));
                    case "-dis" ->
                        weights.put(Stat.DIS, requireWeight(opt, opts));
                    case "-int" ->
                        weights.put(Stat.INT, requireWeight(opt, opts));
                    case "-str" ->
                        weights.put(Stat.STR, requireWeight(opt, opts));
                    case "-minmob" ->
                        mins.put(Stat.MOB, requirePositiveInteger(opt, opts));
                    case "-minres" ->
                        mins.put(Stat.RES, requirePositiveInteger(opt, opts));
                    case "-minrec" ->
                        mins.put(Stat.REC, requirePositiveInteger(opt, opts));
                    case "-mindis" ->
                        mins.put(Stat.DIS, requirePositiveInteger(opt, opts));
                    case "-minint" ->
                        mins.put(Stat.INT, requirePositiveInteger(opt, opts));
                    case "-minstr" ->
                        mins.put(Stat.STR, requirePositiveInteger(opt, opts));
                    default ->
                        throw new AppError("Unknown option: " + opt);
                }
            }
        }

        /**
         * Gets the maximum number of possible armor sets to list.
         * @return The number
         */
        public int getLimit() {
            return limit;
        }

        /**
         * Gets the name of the armor set to compare with.
         * @return The set.
         */
        public String getCompareWith() {
            return compareWith;
        }

        /**
         * Gets the minimum acceptable value for each stat.
         * @return The minimums
         */
        public StatMap getMins() {
            return mins;
        }

        /**
         * Gets a weights to use when ordering the armor sets.
         * @return The weights
         */
        public StatWeights getWeights() {
            return weights;
        }

        //-------------------------------------------------------------------------
        // Helpers

        private String requireString(String opt, Deque<String> opts)
            throws AppError
        {
            if (opts.isEmpty()) {
                throw new AppError("Missing value for " + opt);
            }

            return opts.poll();
        }

        private int requirePositiveInteger(String opt, Deque<String> opts)
            throws AppError
        {
            var valueString = requireString(opt, opts);

            try {
                var value = Integer.parseInt(valueString);

                if (value < 0) {
                    throw new AppError("Invalid " + opt + " value: " + valueString);
                }

                return value;
            } catch (Exception ex) {
                throw new AppError("Invalid " + opt + " value: " + valueString);
            }
        }

        private double requireWeight(String opt, Deque<String> opts)
            throws AppError
        {
            var valueString = requireString(opt, opts);

            try {
                var value = Double.parseDouble(valueString);

                if (value < 0) {
                    throw new AppError("Invalid " + opt + " value: " + valueString);
                }

                return value;
            } catch (Exception ex) {
                throw new AppError("Invalid " + opt + " value: " + valueString);
            }
        }
    }
}
