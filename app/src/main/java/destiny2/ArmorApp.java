/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package destiny2;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.*;

public class ArmorApp {
    //-------------------------------------------------------------------------
    // Instance variables

    private Map<Type, List<Armor>> vault = new HashMap<>();


    //-------------------------------------------------------------------------
    // The App

    public void app(String[] args) {
        if (args.length == 0) {
            println("""
            Usage: armor armor.dat [options...]
                
                -limit num     -- Maximum number of results to display, default is 5
                -mob weight    -- default is 1.0 for each
                -res weight    
                -rec weight
                -dis weight
                -int weight
                -str weight
                -minmob value  -- Minimum stat, default is 0
                -minres value  -- Minimum stat, default is 0
                -minrec value  -- Minimum stat, default is 0
                -mindis value  -- Minimum stat, default is 0
                -minint value  -- Minimum stat, default is 0
                -minstr value  -- Minimum stat, default is 0
            """);
            System.exit(1);
        }

        // NEXT, where are we?
        println("In: " + System.getProperty("user.dir"));

        // NEXT, parse the arguments
        var options = new Options(args);

        // FIRST, load the armor from the file.
        readVault(options.getFileName()).forEach(armor -> {
            vault.putIfAbsent(armor.type(), new ArrayList<Armor>());
            vault.get(armor.type()).add(armor);
        });

        println("\nArmor from " + options.getFileName() + ":\n");
        dumpVault();

        // NEXT, get the current set.
        var current = makeSet(0, 0, 0, 0);

        println("\nEquipped set:\n");
        current.dump();

        // NEXT, generate the possible choices
        var sets = generateSets();

        var comparator = new ArmorComparator(options.getWeights());

        sets.sort(comparator.reversed());

        println("\nPossible Sets by " + comparator + ":\n");

        sets.stream()
            .filter(set -> set.stats().get(Stat.MOB) >= options.getMins().get(Stat.MOB))
            .filter(set -> set.stats().get(Stat.RES) >= options.getMins().get(Stat.RES))
            .filter(set -> set.stats().get(Stat.REC) >= options.getMins().get(Stat.REC))
            .filter(set -> set.stats().get(Stat.DIS) >= options.getMins().get(Stat.DIS))
            .filter(set -> set.stats().get(Stat.INT) >= options.getMins().get(Stat.INT))
            .filter(set -> set.stats().get(Stat.STR) >= options.getMins().get(Stat.STR))
            .limit(options.getLimit())
            .forEach(set -> {
                set.dump();
                println("");
            });
    }

    //-------------------------------------------------------------------------
    // Data Builders

    // Generates all possible armor sets from the available choices.
    private List<ArmorSet> generateSets() {
        var result = new ArrayList<ArmorSet>();

        for (var head = 0; head < vault.get(Type.HEAD).size(); head++) {
            for (var arms = 0; arms < vault.get(Type.ARMS).size(); arms++) {
                for (var body = 0; body < vault.get(Type.BODY).size(); body++) {
                    for (var legs = 0; legs < vault.get(Type.LEGS).size(); legs++) {
                        result.add(makeSet(head, arms, body, legs));
                    }
                }
            }
        }

        return result;
    }

    private ArmorSet makeSet(int head, int arms, int body, int legs) {
        var set = new ArmorSet();

        set.put(Type.HEAD, vault.get(Type.HEAD).get(head));
        set.put(Type.ARMS, vault.get(Type.ARMS).get(arms));
        set.put(Type.BODY, vault.get(Type.BODY).get(body));
        set.put(Type.LEGS, vault.get(Type.LEGS).get(legs));

        return set;
    }


    void dumpVault() {
        for (Type type : Type.values()) {
            for (Armor armor : vault.get(type)) {
                println(armor.data());
            }
        }
    }

    //-------------------------------------------------------------------------
    // File Parsing

    int lineNumber = 0;

    public List<Armor> readVault(String filename) throws AppError {
        var result = new ArrayList<Armor>();

        try {
            Files.lines(new File(filename).toPath())
                .map(line -> {
                    ++lineNumber;
                    return line.trim();
                })
                .filter(line -> !line.isEmpty())
                .filter(line -> !line.startsWith("#"))
                .forEach(line -> result.add(parseArmor(lineNumber, line)));
        } catch (IOException ex) {
            throw new AppError("I/O Error reading data: " + ex.getMessage());
        }

        return result;
    }


    public Armor parseArmor(int lineNumber, String line) throws AppError {
        Scanner scanner = new Scanner(line).useDelimiter("\\s*,\\s*");
        try {
            var type = Type.valueOf(scanner.next());
            var name = scanner.next().trim();
            var armor = new Armor(lineNumber, type, name);

            Stat.stream().forEach(stat -> armor.put(stat, scanner.nextInt()));
            return armor;
        } catch (Exception ex) {
            throw new AppError("Line " + lineNumber + ", " + ex.getMessage());
        }
    }

    void println(String text) {
        System.out.println(text);
    }

    //-------------------------------------------------------------------------
    // Options

    private static class Options {
        private String fileName = null;
        private int limit = 5;
        private final Map<Stat,Integer> mins = new HashMap<>();
        private final Map<Stat,Double> weights = new HashMap<>();

        public Options(String[] args) throws AppError {
            Stat.stream().forEach(s -> mins.put(s, 0));
            Stat.stream().forEach(s -> weights.put(s, 1.0));

            var opts = new ArrayDeque<String>(List.of(args));

            this.fileName = opts.poll();

            while (!opts.isEmpty()) {
                var opt = opts.poll();

                if (!opt.startsWith("-")) {
                    throw new AppError("Expected an option: " + opt);
                }

                switch (opt) {
                    case "-limit":
                        limit = requirePositiveInteger(opt, opts);
                        break;
                    case "-mob":
                        weights.put(Stat.MOB, requireWeight(opt, opts));
                        break;
                    case "-res":
                        weights.put(Stat.RES, requireWeight(opt, opts));
                        break;
                    case "-rec":
                        weights.put(Stat.REC, requireWeight(opt, opts));
                        break;
                    case "-dis":
                        weights.put(Stat.DIS, requireWeight(opt, opts));
                        break;
                    case "-int":
                        weights.put(Stat.INT, requireWeight(opt, opts));
                        break;
                    case "-str":
                        weights.put(Stat.STR, requireWeight(opt, opts));
                        break;
                    case "-minmob":
                        mins.put(Stat.MOB, requirePositiveInteger(opt, opts));
                        break;
                    case "-minres":
                        mins.put(Stat.RES, requirePositiveInteger(opt, opts));
                        break;
                    case "-minrec":
                        mins.put(Stat.REC, requirePositiveInteger(opt, opts));
                        break;
                    case "-mindis":
                        mins.put(Stat.DIS, requirePositiveInteger(opt, opts));
                        break;
                    case "-minint":
                        mins.put(Stat.INT, requirePositiveInteger(opt, opts));
                        break;
                    case "-minstr":
                        mins.put(Stat.STR, requirePositiveInteger(opt, opts));
                        break;
                    default:
                        throw new AppError("Unknown option: " + opt);
                }
            }
        }

        public String getFileName() {
            return fileName;
        }

        public int getLimit() {
            return limit;
        }

        public Map<Stat, Integer> getMins() {
            return mins;
        }

        public Map<Stat, Double> getWeights() {
            return weights;
        }

        private int requirePositiveInteger(String opt, Deque<String> opts)
            throws AppError
        {
            if (opts.isEmpty()) {
                throw new AppError("Missing value for " + opt);
            }

            var valueString = opts.poll();
            try {
                var value = Integer.parseInt(valueString);

                if (value < 0) {
                    throw new AppError("Invalid " + opt + " value: " + valueString);
                }

                return value;
            } catch (Exception ex) {
                throw new AppError("Invalid " + opt + " value: " + valueString);
            }
        }

        private double requireWeight(String opt, Deque<String> opts)
            throws AppError
        {
            if (opts.isEmpty()) {
                throw new AppError("Missing value for " + opt);
            }

            var valueString = opts.poll();
            try {
                var value = Double.parseDouble(valueString);

                if (value < 0) {
                    throw new AppError("Invalid " + opt + " value: " + valueString);
                }

                return value;
            } catch (Exception ex) {
                throw new AppError("Invalid " + opt + " value: " + valueString);
            }
        }
    }

    private static class AppError extends RuntimeException {
        AppError(String message) {
            super(message);
        }
    }

    //-------------------------------------------------------------------------
    // Main
    public static void main(String[] args) {
        try {
            new ArmorApp().app(args);
        } catch (AppError ex) {
            System.out.println("Error: " + ex.getMessage());
        } catch (Exception ex) {
            System.out.println("Unexpected Exception: " + ex.getMessage());
            ex.printStackTrace(System.out);
        }
    }
}
